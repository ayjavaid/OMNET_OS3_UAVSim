<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OMNeT++ Simulation Library: cPacket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cPacket Class Reference<br/>
<small>
[<a class="el" href="group__SimCore.html">Simulation core classes</a>]</small>
</h1><!-- doxytag: class="cPacket" --><!-- doxytag: inherits="cMessage" -->
<p>A subclass of <a class="el" href="classcMessage.html" title="The message class in OMNeT++.">cMessage</a> that can be used to represent packets (frames, datagrams, application messages, etc).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cmessage_8h_source.html">cmessage.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cPacket:</div>
<div class="dynsection">
 <div class="center">
  <img src="classcPacket.png" usemap="#cPacket_map" alt=""/>
  <map id="cPacket_map" name="cPacket_map">
<area href="classcMessage.html" alt="cMessage" shape="rect" coords="0,168,96,192"/>
<area href="classcOwnedObject.html" alt="cOwnedObject" shape="rect" coords="0,112,96,136"/>
<area href="classcNamedObject.html" alt="cNamedObject" shape="rect" coords="0,56,96,80"/>
<area href="classcObject.html" alt="cObject" shape="rect" coords="0,0,96,24"/>
</map>
 </div>
</div>

<p><a href="classcPacket-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, destructor, assignment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6e91a2e6cf9e8ed0bc0b076ddff21286"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40aef58269bc1eedb26bdac2eeec84fb"></a><!-- doxytag: member="cPacket::cPacket" ref="a40aef58269bc1eedb26bdac2eeec84fb" args="(const cPacket &amp;packet)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a40aef58269bc1eedb26bdac2eeec84fb">cPacket</a> (const <a class="el" href="classcPacket.html">cPacket</a> &amp;packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a0cf694ecf45c34746029775d5cedf305">cPacket</a> (const char *name=NULL, short kind=0, int64 bitLength=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55646839fe1c578fce51216014a25bb1"></a><!-- doxytag: member="cPacket::~cPacket" ref="a55646839fe1c578fce51216014a25bb1" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a55646839fe1c578fce51216014a25bb1">~cPacket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcPacket.html">cPacket</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a755e6196a55f62eaffb7bd1ed5c166c1">operator=</a> (const <a class="el" href="classcPacket.html">cPacket</a> &amp;packet)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Redefined cObject member functions.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa1f41a2538be95e9e7389d73943b4719"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcPacket.html">cPacket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#ab9fc1d667cb4da97f9e80a14b7547115">dup</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a586108f74bafebee363878e1c27c2cf6">info</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a72f5fd099e174536614cc75ede77c788">detailedInfo</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#ac473f5ac5a104c3894681cef5558f322">forEachChild</a> (<a class="el" href="classcVisitor.html">cVisitor</a> *v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#aadc39103d03d88433e1d077546cf57fc">parsimPack</a> (<a class="el" href="classcCommBuffer.html">cCommBuffer</a> *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#ad616c8cad83c6bc93506da8527057e3f">parsimUnpack</a> (<a class="el" href="classcCommBuffer.html">cCommBuffer</a> *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a856d696df6581ddcc7e9a96f1ed7257e"></a><!-- doxytag: member="cPacket::isPacket" ref="a856d696df6581ddcc7e9a96f1ed7257e" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a856d696df6581ddcc7e9a96f1ed7257e">isPacket</a> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Length and bit error flag</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp9a1fbe6d76147cc06dd966797a2b32b9"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a0c747caa108271813bcd28b08b80fc2a">setBitLength</a> (int64 l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a4550c6f7653f884c877aba414e7eb2f2">setByteLength</a> (int64 l)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a391450bd41d31535a6ef0d4ec75445c0">addBitLength</a> (int64 delta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a771648c49b5e7894c5eb56a66f90eee9">addByteLength</a> (int64 delta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca4f7244ad5a2e6adc5f97c722832385"></a><!-- doxytag: member="cPacket::getBitLength" ref="aca4f7244ad5a2e6adc5f97c722832385" args="() const " -->
virtual int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#aca4f7244ad5a2e6adc5f97c722832385">getBitLength</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a1e1b8a709e541be5842b2c4da7562b9d">getByteLength</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a303a2babaa717ca4a592f9881208ecb7"></a><!-- doxytag: member="cPacket::setBitError" ref="a303a2babaa717ca4a592f9881208ecb7" args="(bool e)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a303a2babaa717ca4a592f9881208ecb7">setBitError</a> (bool e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02a0212405b1d989bc744897ea32cf0f"></a><!-- doxytag: member="cPacket::hasBitError" ref="a02a0212405b1d989bc744897ea32cf0f" args="() const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a02a0212405b1d989bc744897ea32cf0f">hasBitError</a> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Message encapsulation.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp99261a2b9d5b2265bd089dc61116fa58"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a60f2a48bf1d777342394acd3ddf9fbf3">encapsulate</a> (<a class="el" href="classcPacket.html">cPacket</a> *packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcPacket.html">cPacket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#acfa588354f43317d97bba9b8f35d0c17">decapsulate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcPacket.html">cPacket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a8f3aeb6fc3e192d37e7f7f8f31046c41">getEncapsulatedPacket</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">_OPPDEPRECATED <a class="el" href="classcPacket.html">cPacket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a0d34adab5712970878ca7901f5400e69">getEncapsulatedMsg</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a503338622fc4f996362c71f1a841ce16">hasEncapsulatedPacket</a> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Transmission state</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp0e3d9f81769e0c3059ba6149c9c7a1f8"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">simtime_t_cref&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a90c1d81e03902260172e36e999a882a8">getDuration</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcPacket.html#a37bd97c9d3fc5f82d489e79a1e17e70b">isReceptionStart</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A subclass of <a class="el" href="classcMessage.html" title="The message class in OMNeT++.">cMessage</a> that can be used to represent packets (frames, datagrams, application messages, etc). </p>
<p><a class="el" href="classcPacket.html" title="A subclass of cMessage that can be used to represent packets (frames, datagrams,...">cPacket</a> adds length (measured in bits or bytes), bit error flag, and encapsulation capability to <a class="el" href="classcMessage.html" title="The message class in OMNeT++.">cMessage</a>. Length and bit error flag are significant when the packet travels through a <a class="el" href="classcDatarateChannel.html" title="Channel that models delay, bit error rate and data rate.">cDatarateChannel</a> or another channel that supports data rate and/or error modelling.</p>
<p><a class="el" href="classcPacket.html" title="A subclass of cMessage that can be used to represent packets (frames, datagrams,...">cPacket</a> is rarely used "as is". Typically the user wants to subclass it to create specific packet types for various protocols being modelled. The most convenient way to do that are via message declaration files (.msg), which are translated into C++ classes. An example message declaration:</p>
<div class="fragment"><pre class="fragment"> packet Datagram
 {
     <span class="keywordtype">int</span> destAddr = -1; <span class="comment">// destination address</span>
     <span class="keywordtype">int</span> srcAddr = -1;  <span class="comment">// source address</span>
     <span class="keywordtype">int</span> ttl =  32;     <span class="comment">// time to live</span>
 }
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcSimpleModule.html" title="Base class for all simple module classes.">cSimpleModule</a>, <a class="el" href="classcDatarateChannel.html" title="Channel that models delay, bit error rate and data rate.">cDatarateChannel</a>, <a class="el" href="classcPacketQueue.html" title="A queue class specialized for cPacket objects.">cPacketQueue</a> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0cf694ecf45c34746029775d5cedf305"></a><!-- doxytag: member="cPacket::cPacket" ref="a0cf694ecf45c34746029775d5cedf305" args="(const char *name=NULL, short kind=0, int64 bitLength=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cPacket::cPacket </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>kind</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&nbsp;</td>
          <td class="paramname"> <em>bitLength</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>It takes the packet name, message kind value, and the packet length in bits; all optional. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a391450bd41d31535a6ef0d4ec75445c0"></a><!-- doxytag: member="cPacket::addBitLength" ref="a391450bd41d31535a6ef0d4ec75445c0" args="(int64 delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cPacket::addBitLength </td>
          <td>(</td>
          <td class="paramtype">int64&nbsp;</td>
          <td class="paramname"> <em>delta</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes packet length by the given value (bits). </p>
<p>This is useful for modeling encapsulation/decapsulation. (See also <a class="el" href="classcPacket.html#a60f2a48bf1d777342394acd3ddf9fbf3" title="Encapsulates packet in the packet.">encapsulate()</a> and <a class="el" href="classcPacket.html#acfa588354f43317d97bba9b8f35d0c17" title="Decapsulates a packet from the packet object.">decapsulate()</a>.) The caller must take care that the result does not overflow (i.e. fits into an int64).</p>
<p>The value may be negative (packet length may be decreased too). If the resulting length would be negative, the method throws a <a class="el" href="classcRuntimeError.html" title="Thrown when the simulation kernel or other components detect a runtime error.">cRuntimeError</a>. </p>

</div>
</div>
<a class="anchor" id="a771648c49b5e7894c5eb56a66f90eee9"></a><!-- doxytag: member="cPacket::addByteLength" ref="a771648c49b5e7894c5eb56a66f90eee9" args="(int64 delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cPacket::addByteLength </td>
          <td>(</td>
          <td class="paramtype">int64&nbsp;</td>
          <td class="paramname"> <em>delta</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Changes packet length by the given value (bytes). </p>
<p>This is just a convenience function which invokes <a class="el" href="classcPacket.html#a391450bd41d31535a6ef0d4ec75445c0" title="Changes packet length by the given value (bits).">addBitLength()</a> with 8*l as argument. The caller must take care that the result does not overflow (i.e. fits into an int64). </p>

</div>
</div>
<a class="anchor" id="acfa588354f43317d97bba9b8f35d0c17"></a><!-- doxytag: member="cPacket::decapsulate" ref="acfa588354f43317d97bba9b8f35d0c17" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcPacket.html">cPacket</a>* cPacket::decapsulate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decapsulates a packet from the packet object. </p>
<p>The length of this packet will be decreased by the length of the encapsulated packet, except if it was zero. If the length would become negative, <a class="el" href="classcRuntimeError.html" title="Thrown when the simulation kernel or other components detect a runtime error.">cRuntimeError</a> is thrown. If there is no encapsulated packet, the method returns NULL. </p>

</div>
</div>
<a class="anchor" id="a72f5fd099e174536614cc75ede77c788"></a><!-- doxytag: member="cPacket::detailedInfo" ref="a72f5fd099e174536614cc75ede77c788" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cPacket::detailedInfo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produces a multi-line description of the object's contents. </p>
<p>See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcMessage.html#acf19374e4c09a0c583fb4a338eb937a1">cMessage</a>.</p>

</div>
</div>
<a class="anchor" id="ab9fc1d667cb4da97f9e80a14b7547115"></a><!-- doxytag: member="cPacket::dup" ref="ab9fc1d667cb4da97f9e80a14b7547115" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcPacket.html">cPacket</a>* cPacket::dup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates and returns an exact copy of this object. </p>
<p>See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcMessage.html#a231c291bf665945146df73676f591bc2">cMessage</a>.</p>

</div>
</div>
<a class="anchor" id="a60f2a48bf1d777342394acd3ddf9fbf3"></a><!-- doxytag: member="cPacket::encapsulate" ref="a60f2a48bf1d777342394acd3ddf9fbf3" args="(cPacket *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cPacket::encapsulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcPacket.html">cPacket</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encapsulates packet in the packet. </p>
<p>The packet length gets increased by the length of the encapsulated packet.</p>
<p>IMPORTANT NOTE: IT IS FORBIDDEN TO KEEP A POINTER TO A MESSAGE AFTER IT WAS ENCAPSULATED. For performance reasons, encapsulated packets are reference counted, meaning that the encapsulated packet is not duplicated when you duplicate a packet, but rather, both (all) copies share the same packet instance. Any change done to the encapsulated packet would affect other packets as well. Decapsulation (and even calling <a class="el" href="classcPacket.html#a8f3aeb6fc3e192d37e7f7f8f31046c41" title="Returns a pointer to the encapsulated packet, or NULL if there is no encapsulated...">getEncapsulatedPacket()</a>) will create an own (non-shared) copy of the packet. </p>

</div>
</div>
<a class="anchor" id="ac473f5ac5a104c3894681cef5558f322"></a><!-- doxytag: member="cPacket::forEachChild" ref="ac473f5ac5a104c3894681cef5558f322" args="(cVisitor *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cPacket::forEachChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcVisitor.html">cVisitor</a> *&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls v-&gt;visit(this) for each contained object. </p>
<p>See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcMessage.html#aa04f09128a779c534046207239f7e6c9">cMessage</a>.</p>

</div>
</div>
<a class="anchor" id="a1e1b8a709e541be5842b2c4da7562b9d"></a><!-- doxytag: member="cPacket::getByteLength" ref="a1e1b8a709e541be5842b2c4da7562b9d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 cPacket::getByteLength </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the packet length in bytes, that is, bitlength/8. </p>
<p>If bitlength is not a multiple of 8, the result is rounded up. </p>

</div>
</div>
<a class="anchor" id="a90c1d81e03902260172e36e999a882a8"></a><!-- doxytag: member="cPacket::getDuration" ref="a90c1d81e03902260172e36e999a882a8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">simtime_t_cref cPacket::getDuration </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the transmission duration after the packet was sent through a channel with data rate. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcPacket.html#a37bd97c9d3fc5f82d489e79a1e17e70b" title="Tells whether this packet represents the start or the end of the reception, provided...">isReceptionStart()</a>, <a class="el" href="classcMessage.html#a39358ceaf5e31269d66fa0cc8b603191" title="Returns time when the message arrived (or will arrive if it is currently scheduled...">getArrivalTime()</a>, <a class="el" href="classcDatarateChannel.html" title="Channel that models delay, bit error rate and data rate.">cDatarateChannel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d34adab5712970878ca7901f5400e69"></a><!-- doxytag: member="cPacket::getEncapsulatedMsg" ref="a0d34adab5712970878ca7901f5400e69" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_OPPDEPRECATED <a class="el" href="classcPacket.html">cPacket</a>* cPacket::getEncapsulatedMsg </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DEPRECATED. </p>
<p><a class="el" href="classcPacket.html#a0d34adab5712970878ca7901f5400e69" title="DEPRECATED.">getEncapsulatedMsg()</a> was renamed to <a class="el" href="classcPacket.html#a8f3aeb6fc3e192d37e7f7f8f31046c41" title="Returns a pointer to the encapsulated packet, or NULL if there is no encapsulated...">getEncapsulatedPacket()</a>, this method was left for backward compatibility. </p>

</div>
</div>
<a class="anchor" id="a8f3aeb6fc3e192d37e7f7f8f31046c41"></a><!-- doxytag: member="cPacket::getEncapsulatedPacket" ref="a8f3aeb6fc3e192d37e7f7f8f31046c41" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcPacket.html">cPacket</a>* cPacket::getEncapsulatedPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the encapsulated packet, or NULL if there is no encapsulated packet. </p>
<p>IMPORTANT: see notes at <a class="el" href="classcPacket.html#a60f2a48bf1d777342394acd3ddf9fbf3" title="Encapsulates packet in the packet.">encapsulate()</a> about reference counting of encapsulated packets. </p>

</div>
</div>
<a class="anchor" id="a503338622fc4f996362c71f1a841ce16"></a><!-- doxytag: member="cPacket::hasEncapsulatedPacket" ref="a503338622fc4f996362c71f1a841ce16" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cPacket::hasEncapsulatedPacket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the packet contains an encapsulated packet, and false otherwise. </p>
<p>This method is potentially more efficient than <code><a class="el" href="classcPacket.html#a8f3aeb6fc3e192d37e7f7f8f31046c41" title="Returns a pointer to the encapsulated packet, or NULL if there is no encapsulated...">getEncapsulatedPacket()</a>!=NULL</code>, because it does not need to unshare a shared encapsulated packet (see note at <a class="el" href="classcPacket.html#a60f2a48bf1d777342394acd3ddf9fbf3" title="Encapsulates packet in the packet.">encapsulate()</a>). </p>

</div>
</div>
<a class="anchor" id="a586108f74bafebee363878e1c27c2cf6"></a><!-- doxytag: member="cPacket::info" ref="a586108f74bafebee363878e1c27c2cf6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cPacket::info </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produces a one-line description of the object's contents. </p>
<p>See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcMessage.html#a5fcbee3c0954ec6c16d71a45c1626335">cMessage</a>.</p>

</div>
</div>
<a class="anchor" id="a37bd97c9d3fc5f82d489e79a1e17e70b"></a><!-- doxytag: member="cPacket::isReceptionStart" ref="a37bd97c9d3fc5f82d489e79a1e17e70b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cPacket::isReceptionStart </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether this packet represents the start or the end of the reception, provided the packet has nonzero length and it travelled through a channel with nonzero data rate. </p>
<p>This can be configured on the receiving gate (see <a class="el" href="classcGate.html#a953dc06f3e0900a608abf8fab5aa96bc" title="This method may only be invoked on input gates of simple modules.">cGate::setDeliverOnReceptionStart()</a>).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classcMessage.html#a39358ceaf5e31269d66fa0cc8b603191" title="Returns time when the message arrived (or will arrive if it is currently scheduled...">getArrivalTime()</a>, <a class="el" href="classcPacket.html#a90c1d81e03902260172e36e999a882a8" title="Returns the transmission duration after the packet was sent through a channel with...">getDuration()</a>, <a class="el" href="classcDatarateChannel.html" title="Channel that models delay, bit error rate and data rate.">cDatarateChannel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a755e6196a55f62eaffb7bd1ed5c166c1"></a><!-- doxytag: member="cPacket::operator=" ref="a755e6196a55f62eaffb7bd1ed5c166c1" args="(const cPacket &amp;packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcPacket.html">cPacket</a>&amp; cPacket::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcPacket.html">cPacket</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>packet</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>
<p>Duplication and the assignment operator work all right with <a class="el" href="classcPacket.html" title="A subclass of cMessage that can be used to represent packets (frames, datagrams,...">cPacket</a>. The name member is not copied; see cNamedObject's <a class="el" href="classcPacket.html#a755e6196a55f62eaffb7bd1ed5c166c1" title="Assignment operator.">operator=()</a> for more details. </p>

</div>
</div>
<a class="anchor" id="aadc39103d03d88433e1d077546cf57fc"></a><!-- doxytag: member="cPacket::parsimPack" ref="aadc39103d03d88433e1d077546cf57fc" args="(cCommBuffer *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cPacket::parsimPack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcCommBuffer.html">cCommBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serializes the object into an MPI send buffer Used by the simulation kernel for parallel execution. </p>
<p>See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcMessage.html#a06b28fc3a4c33557ed3cf0c501bc333d">cMessage</a>.</p>

</div>
</div>
<a class="anchor" id="ad616c8cad83c6bc93506da8527057e3f"></a><!-- doxytag: member="cPacket::parsimUnpack" ref="ad616c8cad83c6bc93506da8527057e3f" args="(cCommBuffer *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cPacket::parsimUnpack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcCommBuffer.html">cCommBuffer</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deserializes the object from an MPI receive buffer Used by the simulation kernel for parallel execution. </p>
<p>See <a class="el" href="classcObject.html" title="Root of the OMNeT++ class hierarcy.">cObject</a> for more details. </p>

<p>Reimplemented from <a class="el" href="classcMessage.html#a230773cacf1cb3c80816c30ca5fd3ea6">cMessage</a>.</p>

</div>
</div>
<a class="anchor" id="a0c747caa108271813bcd28b08b80fc2a"></a><!-- doxytag: member="cPacket::setBitLength" ref="a0c747caa108271813bcd28b08b80fc2a" args="(int64 l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cPacket::setBitLength </td>
          <td>(</td>
          <td class="paramtype">int64&nbsp;</td>
          <td class="paramname"> <em>l</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets packet length (in bits). </p>
<p>When the packet is sent through a channel, packet length affects the transmission duration and the probability of setting the bit error flag. </p>

</div>
</div>
<a class="anchor" id="a4550c6f7653f884c877aba414e7eb2f2"></a><!-- doxytag: member="cPacket::setByteLength" ref="a4550c6f7653f884c877aba414e7eb2f2" args="(int64 l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cPacket::setByteLength </td>
          <td>(</td>
          <td class="paramtype">int64&nbsp;</td>
          <td class="paramname"> <em>l</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets packet length (bytes). </p>
<p>This is just a convenience function which invokes <a class="el" href="classcPacket.html#a0c747caa108271813bcd28b08b80fc2a" title="Sets packet length (in bits).">setBitLength()</a> with 8*l as argument. The caller must take care that the result does not overflow (i.e. fits into an int64). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cmessage_8h_source.html">cmessage.h</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Mar 7 17:19:41 2014 for OMNeT++ Simulation Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
